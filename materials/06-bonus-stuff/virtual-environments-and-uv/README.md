# Virtual Environments and UV

Learn how to use virtual environments with `python -m venv .venv` and `uv` for faster package installation and virtual environment creation.

## Background

Every content that you publish to Posit Connect should have its own virtual environment. This will allow us to define the minimum required dependencies that Connect will need to re-run this notebook. We have already define the dependencies in the `requirements.in` file.
cat requirements.in

## Virtual environments with venv

Create and activate a virtual environment with the following commands:

```bash
# Create virtual environment
python3 -m venv .venv

# Activate virtual environment
source .venv/bin/activate

# Update pip and "friends"
python -m pip install --upgrade pip wheel setuptools

# Install all of the requirements
python -m pip install -r requirements.in

# Capture all of the dependencies, including the transitive dependencies.
python -m pip freeze > requirements.txt
```

Why do I use a `requirements.in` and a `requirements.txt`?

- `requirements.in` is for humans. I create and maintain this file by hand. I use it to define the top level dependencies I want to bring into my project.

```bash
# requirements.in
ipykernel==6.29.4
polars==0.20.24
httpx==0.27.0
rsconnect-python==1.23.0
python-dotenv==1.0.1
rich==13.7.1
pins==0.8.6
pyarrow==16.0.0
hishel==0.0.27
```

- `requirements.txt` is for machines. I use this file to capture all of the dependencies, including the transitive dependencies. Posit Connect will use this file to install the dependencies.

```bash
# requirements.txt
# This file was autogenerated by uv via the following command:
#    uv pip compile requirements.in --output-file requirements.txt
anyio==4.3.0
    # via httpx
appdirs==1.4.4
    # via pins
appnope==0.1.4
    # via ipykernel
asttokens==2.4.1
    # via stack-data
certifi==2024.2.2
    # via
    #   httpcore
    #   httpx
    #   requests
charset-normalizer==3.3.2
    # via requests
...
```

## The anatomy of a virtual environment

```bash
tree .venv -L 4

.venv
├── bin
│   ├── activate
│   ├── activate.csh
│   ├── activate.fish
│   ├── Activate.ps1
│   ├── pip
│   ├── pip3
│   ├── pip3.10
│   ├── python -> /opt/python/3.10.11/bin/python
│   ├── python3 -> python
│   └── python3.10 -> python
├── include
├── lib
│   └── python3.10
│       └── site-packages
│           ├── _distutils_hack
│           ├── distutils-precedence.pth
│           ├── pip
│           ├── pip-23.0.1.dist-info
│           ├── pkg_resources
│           ├── setuptools
│           └── setuptools-65.5.0.dist-info
├── lib64 -> lib
└── pyvenv.cfg
```

## Virtual environments with uv

In 2024 an exciting new project called `uv` was released: https://github.com/astral-sh/uv.

> An extremely fast Python package installer and resolver, written in Rust. Designed as a drop-in replacement for common pip and pip-tools workflows.

Install `uv`:

```bash
# On macOS and Linux.
curl -LsSf https://astral.sh/uv/install.sh | sh

# On Windows.
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
```

I have started to adapt `uv` in my projects to replace pip because it is much faster, and has some features that are important to me (like syncing the `requirements.in` and `requirements.txt` files).

First, deactivate and delete your existing virtual environment:

```bash
deactivate
rm -rf .venv
rm requirements.txt
```

Then, recreate it using `uv`:

```bash
# Create virtual environment
uv venv

# Activate virtual environment
source .venv/bin/activate

# Capture all of the dependencies, including the transitive dependencies.
uv pip compile requirements.in --output-file requirements.txt

# Install all of the requirements
pip sync requirements.txt
```

In my daily workflow I use these two aliases everyday!

```bash
alias uvinit='uv venv && source .venv/bin/activate'
alias uvsync='uv pip compile requirements.in --quiet --output-file requirements.txt && uv pip sync requirements.txt'
```

For more information on how I use `uv` check out this blog post: <https://samedwardes.com/blog/2024-04-21-python-uv-workflow/>.

## Tips and best practices

- Version control
    - ✅ Do not check your virtual environments into version control, they are meant to be treated as ephemeral.
    - ✅ Use this .gitignore template from GitHub: https://github.com/github/gitignore/blob/main/Python.gitignore
    - ✅ Do check your requirements.txt into version control
- ✅ Do pin  your versions in the requirements.txt file
- "Vanilla" Virtual environments do have several shortcomings. These tools add additional functionality:
    - uv: https://github.com/astral-sh/uv
    - Poetry: https://python-poetry.org
    - Pipenv: https://github.com/pypa/pipenv
    - Hatch: https://hatch.pypa.io/latest/config/metadata/#dependencies

## venv usage with Jupyter Notebooks

VS Code is easier to work with Jupyter Notebooks with JupyterLab (in our opinion). You can use any virtual environment to run a notebook.

1. Install ipykernel into the virtual environment.
1. Select the virtual environment as the default interpreter.
1. Select the virtual environment as your kernel for the notebook

More details can be found in the Posit Workbench user guide: https://docs.posit.co/ide/server-pro/user/vs-code/guide/python-environments.html.

For instructions on how to use virtual environments with Jupyter Lab see this page from the Posit Workbench user guide: https://docs.posit.co/ide/server-pro/user/jupyter-lab/guide/jupyter-kernel-management.html#user-created-kernels.
